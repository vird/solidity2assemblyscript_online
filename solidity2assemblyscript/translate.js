// Generated by IcedCoffeeScript 108.0.11
(function() {
  var Type, gen, mod_ast, module, translate_type, translate_type_array;

  ;

  Type = window.Type;

  mod_ast = window.mod_ast;

  module = this;

  translate_type_array = function(type) {
    var nest;
    nest = type.nest_list[0];
    return "Array<" + (translate_type(nest)) + ">";
  };

  translate_type = function(type) {
    if (type.is_user_defined) {
      return type.main;
    }
    switch (type.main) {
      case 'bool':
        return 'boolean';
      case 'uint':
        return 'u64';
      case 'int':
        return 'i64';
      case 'address':
        return 'string';
      case 'map':
        return "PersistentMap<" + (translate_type(type.nest_list[0])) + "," + (translate_type(type.nest_list[1])) + ">";
      case 'array':
        return translate_type_array(type);
      case 'bytes':
        return 'Uint8Array';
      default:

        /* !pragma coverage-skip-block */
        pp(type);
        throw new Error("unknown solidity type '" + type + "'");
    }
  };

  this.bin_op_name_map = {
    ADD: '+',
    SUB: '-',
    MUL: '*',
    DIV: '/',
    MOD: '%',
    EQ: '==',
    NE: '!=',
    GT: '>',
    LT: '<',
    GTE: '>=',
    LTE: '<=',
    BIT_AND: '&',
    BIT_OR: '|',
    BIT_XOR: '^',
    BOOL_AND: 'and',
    BOOL_OR: 'or'
  };

  this.bin_op_name_cb_map = {
    ASSIGN: function(a, b) {
      return "" + a + " = " + b;
    },
    ASS_ADD: function(a, b) {
      return "" + a + " += " + b;
    },
    ASS_SUB: function(a, b) {
      return "" + a + " -= " + b;
    },
    ASS_MUL: function(a, b) {
      return "" + a + " *= " + b;
    },
    ASS_DIV: function(a, b) {
      return "" + a + " /= " + b;
    },
    INDEX_ACCESS: function(a, b, ctx, ast) {
      return "" + a + ".getSome(" + b + ")";
    }
  };

  this.un_op_name_cb_map = {
    MINUS: function(a) {
      return "-(" + a + ")";
    },
    BOOL_NOT: function(a) {
      return "!(" + a + ")";
    },
    BIT_NOT: function(a) {
      return "~(" + a + ")";
    },
    BRACKET: function(a) {
      return "(" + a + ")";
    },
    PRE_INCR: function(a) {
      return "++" + a;
    },
    POST_INCR: function(a) {
      return "" + a + "++";
    },
    PRE_DECR: function(a) {
      return "--" + a;
    },
    POST_DECR: function(a) {
      return "" + a + "--";
    }
  };

  this.Gen_context = (function() {
    function Gen_context() {}

    Gen_context.prototype.class_name = null;

    Gen_context.prototype.is_struct = false;

    Gen_context.prototype.mk_nest = function() {
      var t;
      t = new module.Gen_context;
      return t;
    };

    return Gen_context;

  })();

  this.gen = function(ast, opt) {
    var ctx, ret;
    if (opt == null) {
      opt = {};
    }
    ctx = new module.Gen_context;
    ret = module._gen(ast, opt, ctx);
    return "import { context, storage, logging, collections, PersistentMap } from \"near-runtime-ts\";\n" + ret;
  };

  this._gen = gen = function(ast, opt, ctx) {
    var arg_jl, arg_list, aux_export, aux_failtext, body, cb, cond, ctx_lvalue, ctx_orig, f, fn, idx, incr, init, is_a_index_access, is_assign, jl, name, o_type, op, pre, prefix, ret, scope, synth_b, t, type, v, val, _a, _a_col, _a_key, _b, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _synth_b;
    switch (ast.constructor.name) {
      case "Var":
        name = ast.name;
        if (name === 'this') {
          name = 'context.contractName';
        }
        if (name === 'now') {
          name = 'context.blockIndex';
        }
        return name;
      case "Const":
        switch (ast.type.main) {
          case 'string':
            return JSON.stringify(ast.val);
          default:
            return ast.val;
        }
        break;
      case 'Bin_op':
        ctx_lvalue = ctx.mk_nest();
        is_assign = 0 === ast.op.indexOf('ASS');
        is_a_index_access = ast.a.constructor.name === 'Bin_op' && ast.a.op === 'INDEX_ACCESS';
        if (is_assign && is_a_index_access && ast.a.a.type.main === 'map') {
          _a_col = gen(ast.a.a, opt, ctx_lvalue);
          _a_key = gen(ast.a.b, opt, ctx_lvalue);
          if (ast.op === 'ASSIGN') {
            _b = gen(ast.b, opt, ctx);
            return "" + _a_col + ".set(" + _a_key + ", " + _b + ")";
          } else {
            _a = gen(ast.a, opt, ctx_lvalue);
            synth_b = new mod_ast.Bin_op;
            synth_b.op = ast.op.replace('ASS_', '');
            synth_b.a = ast.a;
            synth_b.b = ast.b;
            synth_b.type = ast.a.type;
            _synth_b = gen(synth_b, opt, ctx);
            return "" + _a_col + ".set(" + _a_key + ", " + _synth_b + ")";
          }
        }
        _a = gen(ast.a, opt, ctx_lvalue);
        _b = gen(ast.b, opt, ctx);
        if (op = module.bin_op_name_map[ast.op]) {
          return "(" + _a + " " + op + " " + _b + ")";
        } else if (cb = module.bin_op_name_cb_map[ast.op]) {
          return cb(_a, _b, ctx, ast);
        } else {

          /* !pragma coverage-skip-block */
          throw new Error("Unknown/unimplemented bin_op " + ast.op);
        }
        break;
      case "Un_op":
        if (ast.op === 'NEW') {
          return "new " + (translate_type(ast.a_type));
        } else if (cb = module.un_op_name_cb_map[ast.op]) {
          return cb(gen(ast.a, opt, ctx), ctx);
        } else {

          /* !pragma coverage-skip-block */
          throw new Error("Unknown/unimplemented un_op " + ast.op);
        }
        break;
      case "Field_access":
        t = gen(ast.t, opt, ctx);
        ret = "" + t + "." + ast.name;
        if (ret === 'block.number') {
          ret = 'context.blockIndex';
        }
        if (ret === 'msg.sender') {
          ret = 'context.sender';
        }
        if (ret === 'msg.value') {
          ret = 'context.attachedDeposit';
        }
        return ret;
      case "Fn_call":
        fn = gen(ast.fn, opt, ctx);
        arg_list = [];
        _ref = ast.arg_list;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          v = _ref[_i];
          arg_list.push(gen(v, opt, ctx));
        }
        if (fn === "require" || fn === "assert") {
          aux_failtext = arg_list[1] || "";
          if (aux_failtext) {
            aux_failtext = ", " + aux_failtext;
          }
          return "assert(" + arg_list[0] + aux_failtext + ")";
        }
        if (fn === "revert") {
          return "assert(false)";
        }
        if (fn === "keccak256" || fn === "sha3") {
          return "\"hash(" + (arg_list.join(', ')) + ")\"";
        }
        return "" + fn + "(" + (arg_list.join(', ')) + ")";
      case "Scope":
        jl = [];
        _ref1 = ast.list;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          v = _ref1[_j];
          val = gen(v, opt, ctx);
          if (val[val.length - 1] !== ';') {
            val += ';';
          }
          jl.push(val);
        }
        return join_list(jl, '');
      case "Var_decl":
        type = translate_type(ast.type);
        if (ctx.is_struct) {
          pre = "" + ast.name + ":" + type;
        } else {
          pre = "let " + ast.name + ":" + type;
        }
        if (ast.assign_value) {
          val = gen(ast.assign_value, opt, ctx);
          return "" + pre + " = " + val;
        } else {
          return pre;
        }
        break;
      case "Ret_multi":
        if (ast.t_list.length > 1) {
          throw new Error("not implemented ast.t_list.length > 1");
        }
        jl = [];
        _ref2 = ast.t_list;
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          v = _ref2[_k];
          jl.push(gen(v, opt, ctx));
        }
        return "return " + (jl.join(', '));
      case "If":
        cond = gen(ast.cond, opt, ctx);
        t = gen(ast.t, opt, ctx);
        f = gen(ast.f, opt, ctx);
        return "if (" + cond + ") {\n  " + (make_tab(t, '  ')) + "\n} else {\n  " + (make_tab(f, '  ')) + "\n}";
      case "While":
        cond = gen(ast.cond, opt, ctx);
        scope = gen(ast.scope, opt, ctx);
        return "while (" + cond + ") {\n  " + (make_tab(scope, '  ')) + "\n} ";
      case "For_3pos":
        init = ast.init ? gen(ast.init, opt, ctx) : "";
        cond = gen(ast.cond, opt, ctx);
        incr = ast.incr ? gen(ast.incr, opt, ctx) : "";
        scope = gen(ast.scope, opt, ctx);
        return "for(" + init + ";" + cond + ";" + incr + ") {\n  " + (make_tab(scope, '  ')) + "\n}";
      case "Continue":
        return "continue";
      case "Break":
        return "break";
      case "Class_decl":
        ctx = ctx.mk_nest();
        ctx.class_name = ast.name;
        if (ast.is_struct) {
          ctx.is_struct = true;
        }
        body = gen(ast.scope, opt, ctx);
        if (ast.is_struct) {
          return "export class " + ast.name + " {\n  " + (make_tab(body, "  ")) + "\n}\n";
        } else {
          body = gen(ast.scope, opt, ctx);
          return "// Smart Contract " + ast.name + " START\n" + body + "\n// Smart Contract " + ast.name + " END\n";
        }
        break;
      case "Fn_decl_multiret":
        ctx_orig = ctx;
        ctx = ctx.mk_nest();
        arg_jl = [];
        _ref3 = ast.arg_name_list;
        for (idx = _l = 0, _len3 = _ref3.length; _l < _len3; idx = ++_l) {
          v = _ref3[idx];
          arg_jl.push("" + v + ":" + (translate_type(ast.type_i.nest_list[idx])));
        }
        body = gen(ast.scope, opt, ctx);
        prefix = "";
        if (ctx_orig.class_name != null) {
          prefix = "" + ctx_orig.class_name + "__";
        }
        if (ast.type_o.nest_list.length) {
          o_type = translate_type(ast.type_o.nest_list[0]);
        } else {
          o_type = "void";
        }
        aux_export = "";
        if (ast.visibility === 'public') {
          aux_export = "export ";
        }
        return "" + aux_export + "function " + prefix + ast.name + "(" + (arg_jl.join(', ')) + "):" + o_type + " {\n  " + (make_tab(body, '  ')) + "\n}";
      default:
        if (opt.next_gen != null) {
          return opt.next_gen(ast, opt, ctx);
        }

        /* !pragma coverage-skip-block */
        perr(ast);
        throw new Error("unknown ast.constructor.name=" + ast.constructor.name);
    }
  };

}).call(window.translate = {})
