// Generated by IcedCoffeeScript 108.0.11
(function() {
  var Context, Type, ast, bin_op_map, is_complex_assign_op, post_un_op_map, pre_un_op_map;

  Type = window.Type;

  ast = window.mod_ast;

  bin_op_map = {
    '+': 'ADD',
    '-': 'SUB',
    '*': 'MUL',
    '/': 'DIV',
    '%': 'MOD',
    '&': 'BIT_AND',
    '|': 'BIT_OR',
    '^': 'BIT_XOR',
    '&&': 'BOOL_AND',
    '||': 'BOOL_OR',
    '==': 'EQ',
    '!=': 'NE',
    '>': 'GT',
    '<': 'LT',
    '>=': 'GTE',
    '<=': 'LTE',
    '=': 'ASSIGN',
    '+=': 'ASS_ADD',
    '-=': 'ASS_SUB',
    '*=': 'ASS_MUL',
    '/=': 'ASS_DIV'
  };

  is_complex_assign_op = {
    'ASS_ADD': true,
    'ASS_SUB': true,
    'ASS_MUL': true,
    'ASS_DIV': true
  };

  pre_un_op_map = {
    '-': 'MINUS',
    '+': 'PLUS',
    '~': 'BIT_NOT',
    '!': 'BOOL_NOT',
    '++': 'PRE_INCR',
    '--': 'PRE_DECR'
  };

  post_un_op_map = {
    '++': 'POST_INCR',
    '--': 'POST_DECR'
  };

  Context = (function() {
    Context.prototype.current_contract = null;

    function Context() {}

    return Context;

  })();

  window.solidity_to_ast4gen = function(root) {
    var ctx, loc, node, ret, walk, walk_exec, walk_param, walk_type, _i, _len, _ref;
    walk_type = function(ast_tree, ctx) {
      var ret;
      switch (ast_tree.nodeType) {
        case 'ElementaryTypeName':
          return new Type(ast_tree.name);
        case 'Mapping':
          ret = new Type("map");
          ret.nest_list.push(walk_type(ast_tree.keyType, ctx));
          ret.nest_list.push(walk_type(ast_tree.valueType, ctx));
          return ret;
        case 'ArrayTypeName':
          ret = new Type("array");
          ret.nest_list.push(walk_type(ast_tree.baseType, ctx));
          if (ast_tree.length != null) {
            ret.nest_list.push(ast_tree.length.value);
          }
          return ret;
        case 'UserDefinedTypeName':
          ret = new Type(ast_tree.name);
          ret.is_user_defined = true;
          return ret;
        default:

          /* !pragma coverage-skip-block */
          p(ast_tree);
          throw new Error("walk_type unknown nodeType '" + ast_tree.nodeType + "'");
      }
    };
    walk_param = function(ast_tree, ctx) {
      var ret, t, v, _i, _len, _ref;
      switch (ast_tree.nodeType) {
        case 'ParameterList':
          ret = [];
          _ref = ast_tree.parameters;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            v = _ref[_i];
            ret.append(walk_param(v, ctx));
          }
          return ret;
        case 'VariableDeclaration':
          if (ast_tree.value) {
            throw new Error("ast_tree.value not implemented");
          }
          ret = [];
          t = walk_type(ast_tree.typeName, ctx);
          t._name = ast_tree.name;
          ret.push(t);
          return ret;
        default:

          /* !pragma coverage-skip-block */
          p(ast_tree);
          throw new Error("walk_param unknown nodeType '" + ast_tree.nodeType + "'");
      }
    };
    walk_exec = function(ast_tree, ctx) {
      var decl, node, op, ret, v, _i, _j, _len, _len1, _ref, _ref1;
      switch (ast_tree.nodeType) {
        case 'Identifier':
          ret = new ast.Var;
          ret.name = ast_tree.name;
          ret.type = new Type(ast_tree.typeDescriptions.typeIdentifier);
          return ret;
        case 'Literal':
          ret = new ast.Const;
          ret.type = new Type(ast_tree.kind);
          ret.val = ast_tree.value;
          return ret;
        case 'Assignment':
          ret = new ast.Bin_op;
          ret.op = bin_op_map[ast_tree.operator];
          if (!ret.op) {

            /* !pragma coverage-skip-block */
            throw new Error("unknown bin_op " + ast_tree.operator);
          }
          ret.a = walk_exec(ast_tree.leftHandSide, ctx);
          ret.b = walk_exec(ast_tree.rightHandSide, ctx);
          return ret;
        case 'BinaryOperation':
          ret = new ast.Bin_op;
          ret.op = bin_op_map[ast_tree.operator];
          if (!ret.op) {

            /* !pragma coverage-skip-block */
            throw new Error("unknown bin_op " + ast_tree.operator);
          }
          ret.a = walk_exec(ast_tree.leftExpression, ctx);
          ret.b = walk_exec(ast_tree.rightExpression, ctx);
          return ret;
        case 'MemberAccess':
          ret = new ast.Field_access;
          ret.t = walk_exec(ast_tree.expression, ctx);
          ret.name = ast_tree.memberName;
          return ret;
        case 'IndexAccess':
          ret = new ast.Bin_op;
          ret.op = 'INDEX_ACCESS';
          ret.a = walk_exec(ast_tree.baseExpression, ctx);
          ret.b = walk_exec(ast_tree.indexExpression, ctx);
          return ret;
        case 'UnaryOperation':
          ret = new ast.Un_op;
          if (ast_tree.prefix && (op = pre_un_op_map[ast_tree.operator])) {
            ret.op = op;
          } else if (!ast_tree.prefix && (op = post_un_op_map[ast_tree.operator])) {
            ret.op = op;
          } else {

            /* !pragma coverage-skip-block */
            throw new Error("unknown un_op " + ast_tree.operator + " prefix=" + ast_tree.prefix);
          }
          ret.a = walk_exec(ast_tree.subExpression, ctx);
          return ret;
        case 'FunctionCall':
          ret = new ast.Fn_call;
          ret.fn = walk_exec(ast_tree.expression, ctx);
          _ref = ast_tree["arguments"];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            v = _ref[_i];
            ret.arg_list.push(walk_exec(v, ctx));
          }
          return ret;
        case 'NewExpression':
          ret = new ast.Un_op;
          ret.op = 'NEW';
          ret.a_type = walk_type(ast_tree.typeName, ctx);
          return ret;
        case 'ExpressionStatement':
          return walk_exec(ast_tree.expression, ctx);
        case 'VariableDeclarationStatement':
          if (ast_tree.declarations.length !== 1) {
            throw new Error("ast_tree.declarations.length != 1");
          }
          decl = ast_tree.declarations[0];
          if (decl.value) {
            throw new Error("decl.value not implemented");
          }
          ret = new ast.Var_decl;
          ret.name = decl.name;
          ret.type = walk_type(decl.typeName, ctx);
          if (ast_tree.initialValue) {
            ret.assign_value = walk_exec(ast_tree.initialValue, ctx);
          }
          return ret;
        case "Block":
          ret = new ast.Scope;
          _ref1 = ast_tree.statements;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            node = _ref1[_j];
            ret.list.push(walk_exec(node, ctx));
          }
          return ret;
        case "IfStatement":
          ret = new ast.If;
          ret.cond = walk_exec(ast_tree.condition, ctx);
          ret.t = walk_exec(ast_tree.trueBody, ctx);
          if (ast_tree.falseBody) {
            ret.f = walk_exec(ast_tree.falseBody, ctx);
          }
          return ret;
        case 'WhileStatement':
          ret = new ast.While;
          ret.cond = walk_exec(ast_tree.condition, ctx);
          ret.scope = walk_exec(ast_tree.body, ctx);
          return ret;
        case 'ForStatement':
          ret = new ast.For_3pos;
          if (ast_tree.initializationExpression) {
            ret.init = walk_exec(ast_tree.initializationExpression, ctx);
          }
          ret.cond = walk_exec(ast_tree.condition, ctx);
          if (ast_tree.loopExpression != null) {
            ret.incr = walk_exec(ast_tree.loopExpression, ctx);
          }
          ret.scope = walk_exec(ast_tree.body, ctx);
          return ret;
        case 'Continue':
          return new ast.Continue;
        case 'Break':
          return new ast.Break;
        case 'Return':
          ret = new ast.Ret_multi;
          ret.t_list.push(walk_exec(ast_tree.expression, ctx));
          return ret;
        case 'TupleExpression':
          if (ast_tree.components.length !== 1) {
            throw new Error("Tuples not supported ast_tree.components.length != 1 not supported");
          }
          ret = new ast.Un_op;
          ret.op = 'BRACKET';
          ret.a = walk_exec(ast_tree.components[0], ctx);
          ret.type = ret.a.type;
          return ret;
        default:

          /* !pragma coverage-skip-block */
          p(ast_tree);
          throw new Error("walk_exec unknown nodeType '" + ast_tree.nodeType + "'");
      }
    };
    walk = function(ast_tree, ctx) {
      var fn, member, name, node, ret, v, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      switch (ast_tree.nodeType) {
        case "PragmaDirective":
          name = ast_tree.literals[0];
          if (name === 'solidity') {
            return;
          }
          if (name === 'experimental') {
            return;
          }

          /* !pragma coverage-skip-block */
          throw new Error("unknown pragma '" + name + "'");
          break;
        case "VariableDeclaration":
          ret = new ast.Var_decl;
          ret._const = ast_tree.constant;
          ret.name = ast_tree.name;
          ret.type = walk_type(ast_tree.typeName, ctx);
          if (ast_tree.value) {
            ret.assign_value = walk_exec(ast_tree.value, ctx);
          }
          return ret;
        case "FunctionDefinition":
          fn = ctx.current_function = new ast.Fn_decl_multiret;
          fn.name = ast_tree.name || 'constructor';
          fn.visibility = ast_tree.visibility;
          fn.type_i = new Type('function');
          fn.type_o = new Type('function');
          fn.type_i.nest_list = walk_param(ast_tree.parameters, ctx);
          fn.type_o.nest_list = walk_param(ast_tree.returnParameters, ctx);
          _ref = fn.type_i.nest_list;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            v = _ref[_i];
            fn.arg_name_list.push(v._name);
          }
          if (ast_tree.modifiers.length) {
            throw new "ast_tree.modifiers not implemented";
          }
          if (ast_tree.body) {
            fn.scope = walk_exec(ast_tree.body, ctx);
          } else {
            fn.scope = new ast.Scope;
          }
          return fn;
        case "ContractDefinition":
          ctx.current_contract = new ast.Class_decl;
          ctx.current_contract.name = ast_tree.name;
          _ref1 = ast_tree.nodes;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            node = _ref1[_j];
            ctx.current_contract.scope.list.push(walk(node, ctx));
          }
          return ctx.current_contract;
        case "StructDefinition":
          ret = new ast.Class_decl;
          ret.name = ast_tree.name;
          ret.is_struct = true;
          _ref2 = ast_tree.members;
          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
            member = _ref2[_k];
            ret.scope.list.push(walk(member, ctx));
          }
          return ret;
        default:

          /* !pragma coverage-skip-block */
          p(ast_tree);
          throw new Error("walk unknown nodeType '" + ast_tree.nodeType + "'");
      }
    };
    ret = new ast.Scope;
    ctx = new Context;
    _ref = root.nodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      loc = walk(node, ctx);
      if (loc) {
        ret.list.push(loc);
      }
    }
    return ret;
  };

}).call(this);
